#!/usr/bin/env pebl
##  This is a PEBL script that acts as a cross-platform 
##  launcher for PEBL.
##
## Version 0.3: Adds parameter setting (version 0.14), 
## data file combining, http version check.  
##
##  Version 0.2: Initial release, to accompany PEBL 0.13.
##  (c) 2011-2014 Shane T. Mueller, Ph.D. smueller@obereed.net
##

define Start(p)
{

    gdebug <- 0
    gUseReloc <-  0  ##Set this from 0 to 1 if you want to run on windows 
                   ## NOT from an installation in Program Files, but from
                   ##A PEBL subdirectory of the current working directory.
    gPEBLVersion <- "0.14"
 
     if(gDebug)
     {
	   gWin <- MakeWindow()
   
	   gMessage <- EasyLabel("Started",200,200,gWin,12)
           Draw()
 	   WaitForANyKeyPress()
	  }
     gsystemType <- GetSystemType()
     ghome <- GetHomeDirectory()
	
	
    if (gUseReloc)
	    {
 	    gPEBLDIR <- "PEBL"
            gDest <- ".\" ##was ghome. 
            gHome <- ""

		   FileSelect(["default"],p) ##Giving an argument here will specify a data file
		} else {
	
     if(Length(p)>0)
	  {
  	       gPEBLDir  <- First(p)
	  } else {
           gPEBLDir <- GetWorkingDirectory()+"\..\"
	  }
	  # gPEBLDir <- GetWorkingDirectory()+"\..\"
	  # gPEBLDir <- ""
	  
	  if(gDebug)
	  {
        gMessage.text <- gPEBLDir
	    Draw()
	    WaitForANyKeyPress()
	  }
	  

	if(gSystemtype == "WINDOWS")
	   {
 	    if(FileExists(ghome+"\Documents"))
	    {
		   doc <- "\Documents"    ##win7 or later?
		} elseif (FileExists(ghome+"\My Documents"))
		{
		   ##winxp or earlier?
		   doc <- "\My Documents"
		} else {
		
		    #We should allow user-selected here, but it will take  a little care to do right.
		    SignalFatalError("Unable to locate My Documents or Documents folder")
		}
		
        } else {
	     #On linux/osx
             doc <- "/Documents"
	}

      gDest <- ghome+ doc + "/pebl-exp."+gPEBLVersion
      Print("starting in " + gDest)

	 
     ##Decide whether to run for the first time
	  if(FileExists(gdest))
	   {
	     list <- GetDirectoryListing(gdest)

	      if(Length(list)>2)
               {
                 SetWorkingDirectory(gdest)
                  FileSelect(["default.config"],p) ##Giving an argument here will specify a data file
                 } else{
                  RunFirstTime(p)
		 }
            } else {

	       Print("Running for the first time")
	       RunFirstTime(p)
	  }
  }
}


define FileSelect(p,resources)
{
  
 ##Set this from 1 to 0 to turn off automatic subject code incrementation
 ##it increments the previous code by one, to avoid overwriting
 gAutoSubCode <- 1

 gLastUpdate <- GetTime() ##keep track of updates

 gScreenresInitial <- GetCurrentScreenResolution()

 ###set the configuration/chain name: use 'default.config' as default.
 if(Length(p) >0)
   {
      gConfigName <- First(p)
      if(gConfigName==0)
        {
           gConfigName <- "default.config"
        }
    }else{
       gConfigName <- "default.config"
   }

  ##This allows you to open up the description file directly.
  gEditDescription <- 0

  systemType <- GetSystemType()

   gFilters <- ["*.pbl" , "data files","*.*"]

  if(systemType == "LINUX") 
   {

    gViewerCommand <- "gedit"
    gPEBLName      <- "pebl"
    gOpenManual    <- "acroread /usr/local/share/pebl/doc/PEBLManual"+gPEBLVersion+".pdf&"
    gOpenURL        <- "firefox"
    gManualLoc      <- "/usr/local/share/pebl/doc/PEBLManual"+gPEBLVersion+".pdf"

		
   }elseif(systemType=="WINDOWS")   {
     
	 
	 	  ##Debugging:
      #SystemCall("echo " + gQuote+ gPEBLDir+gQuote +" & pause","")
	  #SystemCall("dir "+gQuote+"%ProgramFiles%\PEBL\bin\pebl.exe"+gQuote +"&pause","")
      #SystemCall("dir "+gQuote+"%ProgramFiles(x86)%\PEBL\bin\pebl.exe"+gQuote+"&pause","")
	
	 ##There should be a built-in that does this.
	 ##	Print(gPeblDir+"\bin\pebl.exe")
	 ##	Print(GetDirectoryListing(".\"))
	if (not FileExists(gPEBLDir+"\bin\pebl.exe"))
	 	     {

			  if(FileExists(gQuote+"%ProgramFiles(x86)%\PEBL\bin\pebl.exe"+gQuote))
			  {
  		           gPEBLDir <- "%ProgramFiles(x86)%\PEBL"
			   } elseif(FileExists(gQuote+"%ProgramFiles%\PEBL\bin\pebl.exe"+gQuote))
			   {
			     gPEBLDir <- gQuote+"%ProgramFiles%\PEBL"+ gQuote
			   } else {
			      if(gDebug)
				   {
                     MessageBox("Unable to fine PEBL Base Directory.  Please hard-code",gWin)
                   }
                   gPEBLDir <- "%ProgramFiles%\PEBL"
                   SignalFatalError("Unable to find PEBL Base Directory.")
				}
			}
    
     gViewerCommand <- "c:\windows\notepad.exe"  ##used as a backup
#     gPEBLName      <- "c:\Progra~1\PEBL\bin\pebl.exe "
     gPEBLName     <- gQuote+gPEBLDir+"\bin\pebl.exe"+gQuote+ " "
     gOpenManual    <- ""
     gManualLoc     <-  gQuote+gPEBLDir+"\doc\PEBLManual"+gPEBLVersion+".pdf"+gQuote
     ##This shouldn't be hard-coded; but for now, change to localize.
#     gManualLoc    <- "C:\Program Files\PEBL\doc\PEBLManual"+gPEBLVersion+".pdf"
     gOpenURL       <- ""

 if(gDebug)
	  {
	     MessageBox("pebl.exe:" + gPEBLName,gWin)
	   }

   }elseif(systemType == "OSX")
   {
     gViewerCommand <- "open"
#     gPEBLName      <- "/opt/local/bin/pebl"
#     gOpenManual    <- "acroread /opt/local/share/pebl/doc/PEBLManual"+gPEBLVersion+".pdf"
 

     gPEBLName      <- gExecutableName
     Print("PEBL NAME:"+gPEBLName)
     Print("PEBL NAME:"+gPEBLDir)

     gOpenManual    <- ""
     gManualLoc     <- "PEBLManual"+gPEBLVersion+".pdf"

   }

   gSleepEasy <- 1



   ReadConfigFile(gConfigname)
   if(not FileExists(gConfigName))
   {
      Saveconfig(gconfigname)
   }


           	   
    parPairs <- [["checkfornew",0],
                 ["newest","0.14"],
		          ["pwhash",""],
				  ["screensize", "large"]
                ]


    MakeDirectory("params")		 
    gParams  <- CreateParameters(parpairs,"params/launcher.pbl.par")
    	    
   
   if(gParams.ScreenSize =="large")
   {
     gVideoWidth <- 1000
     gVideoheight <- 700
   }elseif(gParams.ScreenSize=="small")
   {
     gVideoWidth <- 1000
     gVideoheight <- 600
   }


   win <- MakeWindow("grey90")
   gWin <- win
   if(not gParams.pwhash=="2627692e567165c7a474f3ea97c07912")
   {
      Draw()        
      PopUpScreen(win)
   }

   SaveParamFile(gParams,"params/launcher.pbl.par")
   
   ##make a dummy object INSIDE() will recognize as a click on the window.
   gWinDummy <- MakeCustomObject("dummy")
   gWinDummy.name <- "<CUSTOMOBJECT>"
   gWinDummy.x <- gVideoWidth/2
   gWinDummy.y <- gvideoHeight/2
   gWinDummy.width <- gVideoWidth
   gWinDummy.height <- gVideoheight
   gWinDummy.win <- win


  ##Now, determine the proper translation strings.
  GetStrings(gLanguage)

   fontsize <- 11
   yheight <- 14 

   menubar <- Rectangle(gVideoWidth/2,8,gVideoWidth,16,MakeColor("grey20"),1)
   AddObject(menubar,win)
   menu1 <- MakeMenu("File",10,0,win,14,120,
              ["Quit"],
              ["ExitPEBL"])

   menu2<- MakeMenu("Options",90,0,win,14,120,    
              ["Change launcher size","Set password"],
              ["ChangeLauncherSize","SetPassword"])

    menu3 <- MakeMenu("Help",180,0,win,14,120,["About","Manual","Website", "PEBL Wiki","Tutorial","Review PEBL","Donate"],
          ["AboutMessage","OpenManual","GoToWeb","VisitWIKI","Tutorial","Review","Donate"])



  if(gFullscreen)
    {
      fstext  <- "X"
    } else { 
      fstext <- ""
    }

   ##keep track of the gOffset/select pairs when you move to new directories.
   selectStack <- []
   gselected <-1     #Which item is selected in the fileview
   gOffset <- 0      #gOffset in the fileview


   logFile <- FileOpenAppend("PEBLLaunch-log.txt")

   xbase <- 10

   gDirchain <- ["."]  ##this is a history of the directories you have 
                      ##navigated to.

######################################################
#####################################################
 ## first column of stuff
   ybase1 <- 34  ##base of column 1
#   gYbase <- ybase1

   gPath <- EasyLabel(DirListToText(gDirChain),(xbase+100), ybase1+15, win,fontsize)
   yheight <- gPath.height
   gYHeight <- yHeight
   MoveCorner(gPath,xbase,ybase1+10)

   portalheight <- 418
   gfilelist <- FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),gDirChain,First(gFilters))
   gFlatfilelist <- Flatten(gfilelist)
   dirlist <- DirToText(First(gfilelist),Second(gfilelist),   
                             gOffset,gDirChain)


  gPortal <- MakeScrollbox(dirlist,"File listing",
                             xbase,ybase1+27,
			     win,fontsize,
			     200, portalheight,1)



   font <- MakeFont(gPEBLBaseFont,0,fontsize,MakeColor("black"),MakeColor("white"),1)

  
   run     <- MakeButton(gRuntext,xbase+100,ybase1,win,200) 


   edit  <- MakeButton(gOpenText,gPortal.x+gPortal.width/2,  gPortal.y+portalheight+14,win,gportal.width-4)
   wiki  <- MakeButton(gWikiText,gPortal.x+gPortal.width/2,  gPortal.y+portalheight+35,win,gportal.width-4)
   combinedata <- MakeButton(gCombineDataText,gPortal.x+gPortal.width/2,gPortal.y+portalheight+56,win,gportal.width-4)
   viewoutput <- MakeButton(gViewDebugText,gPortal.x+gPortal.width/2, gportal.y+portalheight+77,win,gportal.width-4)
   viewerror  <- MakeButton(gViewErrorText,gPortal.x+gPortal.width/2, gPortal.y+portalheight+98,win,gportal.width-4)

 
   ##################################################
   ##################################################
   ##column 2
   ybase2 <- 35   #base of column 2

   wd   <- EasyLabel("dir: "+GetWorkingDirectory(),(xbase+100), ybase2-25, win,fontsize)
   MoveCorner(wd,xbase+220,ybase2-15)

   ##################################################
   ##################################################
   ##  
   ##  graphical widgets related to the chain launcher.

   ##chain-launcher
#   chaintitle <- EasyLabel(gExpChainText+gConfigName,xbase+210+150,290,win,18)

   chainbox <- MakeScrollbox(MakeExpChainList(gExpChain),gExpchainText+gconfigName,
                        xbase+210,ybase2+165,win,fontsize,340,200,1)
   
   box <- chainbox.outer
   box.height <- chainbox.height + 50
   box.y <- box.y + 25
   loadchain  <- MakePulldown(GetConfigFiles(),chainbox.x+10,chainbox.y+chainbox.height-15,win,fontsize,chainbox.width-32,1)
   ##try to select gConfigName:
   index <- 1
   loop(i,loadchain.list)
   {

    if(i == gConfigName)
     {
       loadchain.selected <- index
       DrawPulldown(loadchain)
     }
    index <- index + 1 
   }

   launchchain <- MakeButton(gLaunchChainText,chainbox.x+90,
         chainbox.y+chainbox.height+63,win,180)

   randomizeChainBox <-  MakeCheckBox(gRandomizeChainText,
          chainbox.x+chainbox.width-150,
          chainbox.y+chainbox.height+53,win,150)

   SetCheckBox(randomizechainBox,gRandomizeChain)


   insertinchain <- MakeButton(gInsertChainText,xbase+270,chainbox.y+chainbox.height+13,win,95)
   addtochain <- MakeButton(gAddToChainText,xbase+270,chainbox.y+chainbox.height+35,win,95)

   clearchain <- MakeButton(gClearChainText,xbase+370,chainbox.y+chainbox.height+13,win,95)
   deletestep <- MakeButton(gDeleteStepText,xbase+370,chainbox.y+chainbox.height+35,win,95)

   deletechain <- MakeButton(gDeleteChainText,xbase+470,chainbox.y+chainbox.height+13,win,95)
   savechain <- MakeButton(gSaveChainText,xbase+470,chainbox.y+chainbox.height+35,win,95)


   subjectbox <- EasyTextBox(gsubcode,xbase+350,ybase2+20,win,fontsize,60,yheight)
   sublabel   <- EasyLabel(gPartCode, xbase+270,subjectbox.y+subjectbox.height/2,win,fontsize)
   MoveCorner(sublabel,subjectbox.x-sublabel.width-10,subjectbox.y)
   subboxhighlight <- Rectangle(subjectbox.x+subjectbox.width/2,subjectbox.y+subjectbox.height/2,subjectbox.width,subjectbox.height,MakeColor("red"),0)
   AddObject(subboxhighlight,win)
   Hide(subboxhighlight)

   subplusbutton <-  MakeButton("+",subjectbox.x+subjectbox.width+20,subjectbox.y+5,win,20)

   filter    <- MakeButton("*.pbl",gPortal.x+95,gportal.y+gPortal.height-12,win,172)

###Experimenter code box:
   expbox <- EasyTextBox(gexperimenter,xbase+350,ybase2+40,win,fontsize,60,yheight)
   explabel   <- EasyLabel(gExperCode, expbox.x,expbox.y,win,fontsize)
   MoveCorner(explabel,expbox.x-explabel.width-10,expbox.y)
   expboxhighlight <- Rectangle(expbox.x+expbox.width/2,expbox.y+expbox.height/2,expbox.width,expbox.height,MakeColor("red"),0)
   AddObject(expboxhighlight,win)
   Hide(expboxhighlight)


### Language box:
   langbox <- EasyTextBox(glanguage,xbase+350,ybase2+80,win,fontsize,60,yheight)
   langlabel   <- EasyLabel(gLangCode, langbox.x,langbox.y,win,fontsize)
   MoveCorner(langlabel,langbox.x-langlabel.width-10,langbox.y)
   langboxhighlight <- Rectangle(langbox.x+langbox.width/2,langbox.y+langbox.height/2,langbox.width,langbox.height,MakeColor("red"),0)
   AddObject(langboxhighlight,win)
   Hide(langboxhighlight)


###Command-line options:
   clobox <- EasyTextBox(gCommandLineText,langbox.x,langbox.y+20,win,fontsize,200,yheight)
   clolabel   <- EasyLabel(gCommandLineOptions, expbox.x,expbox.y,win,fontsize)
   MoveCorner(clolabel,clobox.x-clolabel.width-10,clobox.y)
   cloboxhighlight <- Rectangle(clobox.x+clobox.width/2,clobox.y+clobox.height/2,clobox.width,clobox.height,MakeColor("red"),0)
   AddObject(cloboxhighlight,win)
   Hide(cloboxhighlight)


### parameter set pulldown:

   psetlabel   <- EasyLabel(	gParameterLabel, expbox.x,expbox.y+20,win,fontsize)
   psetbox <- MakePulldown(["default"],langbox.x,langbox.y+40,win,fontsize,200,1)
   MoveCorner(psetlabel,psetbox.x-psetlabel.width-10,psetbox.y)   


   params     <- MakeButton(gEditParams,psetlabel.x-psetlabel.width/2-30,psetlabel.y,win,50)
### screen resolution

  screenselection <- MakePulldown([gScreenRes],expbox.x,expbox.y+expbox.height+5,win,fontsize,150,1)
  gCustomScreenRes <- ""
  UpdateScreenResPulldown(screenselection)

#  screenselection.selected <- Length(screenselection.list)-1
  DrawPulldown(screenselection)



  screenlabel <- EasyLabel(gScreenResLabel,expbox.x,expbox.y+20,win,fontsize)
  Move(screenlabel,screenselection.x-screenlabel.width/2-10,screenselection.y+screenlabel.height/2)

#####################################
   ##Fullscreen checkbox:
  fullscreenbox <-  MakeCheckBox(gFulltext,xbase+210,ybase2+140,win,120)

   demobox <-  MakeCheckBox(gCollectDemoText,xbase+345,ybase2+140,win,200)
   ##Demographics checkbox:
   SetCheckBox(demobox,gNIMHdemographics)

   gPortal.list <- DirToText(First(gfilelist),Second(gfilelist),   
                             gOffset,gDirChain)

   UpdateScrollbox(gPortal)			    
   DrawScrollbox(gPortal)



   

   #if(gParams.checkfornew)
   if(0)
   {

     newestlabel <- Easylabel("checking for new version", xbase+250, ybase1,win,fontsize)
     MoveCorner(newestlabel,xbase+135,ybase1+20)

#        newest <- GetHTTPText("pebluser.s3-website-us-east-1.amazonaws.com","/latest.txt")
         newest <- ["0.14",100]

     if(First(newest)==200)
	{
	  newestversion <- Second(newest)
	  if(newestversion == "0.14"+CR(1))
           {
                newlab <- "PEBL Up-to-date: Version:"+newestversion
           } else {
                newlab <- "PEBL Out-of-date: Version "+newestversion+" available."
           }
         } else{
              newlab <- GetPEBLVersion()

         }
   }else{

    newlab <-"PEBL Version "+gPEBLVersion
   }

#   newestlabel.text  <- newlab
#   MoveCorner(newestlabel,xbase+100+newestlabel.width/2,ybase2)

   pselected <- -1
   parfiles <- []



############################################
## Column 3
############################################



#   gDescription <- MakeTextBox(gNoDesc,font,420,120)
#   AddObject(gDescription,win)
#   Move(gDescription,570,25)

  gDescription <- MakeScrollingTextBox(gNoDesc,570,25,win,
                                10,420,120,1)


   title <- MakeMenuItem(gPEBLTitle+ GetPEBLVersion(),
                    gVideoWidth/2+100,0,win,14,150,"Draw")

   gScreenshotbase <- Rectangle(780,313,420,320,MakeColor("black"),1)
   gScreenshotdummy <- Rectangle(780,313,400,300,MakeColor("white"),1)
   AddObject(gScreenshotbase,win)
   AddObject(gScreenshotdummy,win)
   gScreenshot <- gScreenshotdummy

#########################
########################
## Bottom text windows

  scrollx <- xbase+gPortal.width+10
  scrolly <- gPortal.y+gPortal.height
  scrollw <- gVideoWidth-scrollX - 10
  scrollH <- gVideoHeight-scrollY - 10

  gStdErrList <- ["file: stderr.txt"]
  gStdOutList <- ["file: stdout.txt"]

  gMessageBox <- MakeScrollingTextBox(First(gStdOutList),scrollX, scrollY,win,
                                   fontsize,scrollW,scrollH,1)

  fptb <- gMessageBox.box
  fptb.font <- Makefont(gPEBLBaseFontMono,0,fontsize,MakeColor("black"),MakeColor("white"),0)

  gMenuStdOut <- MakeMenuItem("Debug messages",gMessageBox.x+9,    gMessageBox.y-3,win,14,140,"UpdateStdOut")
  gMenuStdErr <- MakeMenuItem("Error messages",gMessageBox.x+160,  gMessageBox.y-3,win,14,140,"UpdateStdErr")

  gMenuReload <-  MakeMenuItem("Reload",gMessagebox.x+310,gMessageBox.y-3,win,14,80,"ReloadStdOutErr")

  gStdouthighlight <- Rectangle(gMenuStdOut.x+gMenuStdout.width/2,
                               gMenuStdOut.y+gMenuStdout.height/2,
                               gMenuStdOut.width+2,gMenuStdOut.height+2,
			       MakeColor("blue"),0)

  AddObject(gStdouthighlight,win)			       
  UpdateStdout(gMenuStdOut,[0,0])





   Draw()
   gCont <- 1
   while(gCont)
    { 

   ########################################
   ##This updates the parfiles if needed.
   ##it should probably be contingent on portal-clicking...
    prevparfiles <- parfiles
    parfiles <- GetParFiles()   
    if(not ListEqual(prevparfiles,parfiles))
    {
       ##we need to update the pbox here.
       UpdatePulldown(psetbox,parfiles)
       pselected <- psetbox.selected

    }

        Draw()

       vals <- [gPortal,chainbox,insertinchain,deletestep,gMessageBox,
	   run,subjectbox,fullscreenbox,expbox,langbox,
	   addtochain,clearchain,launchchain,viewoutput,viewerror,
	   edit,gMenuStdErr,gMenuStdOut,gMenuReload,
	   gDescription,demobox,savechain,loadchain,wiki,
           subplusbutton,clobox,filter,#donate,review,
           screenselection, randomizeChainBox,params,  combinedata,psetbox,
          deletechain,menu1,menu2,menu3]

      returns <- 		   [1,2,3,4,0,
				   6,7,8,9,10,
				   11,12,13,14,15,
				   16,0,0,0,
				   21,22,23,24,25,
				   26,27,28,#29,30,
				   31,32,33,34,35,
				   36,0,0,0]

   resp <-  WaitForButtonClickOnTarget(vals,returns)

   tmp <- First(resp)
   click <- Second(resp)
   obj <- Third(resp)
   if(tmp==0)
    {
       ##anything coded 0 should be able to handle itself:
       Callfunction(obj.clickon,[obj,click])

    }elseif(tmp==1)  #Click was on the portal.
      {
         event <- ClickOnScrollbox(gPortal,gClick)
         newselected <- gPortal.selected

	 ##Most of the updates only matter if we did a selection action.
	 if(event == "<select>")
	 {
          if(gselected == newselected)
	   {

             ##We are selecting something we just selected.open 
              ##directory
              if(IsDirectory(DirListTotext(gDirChain)+Nth(gFlatFileList,gselected)))
                {		

                  gDirChain <- AppendDirlist(gDirChain,Nth(gFlatFileList,gselected))
 
	          if(Length(gDirChain)<(Length(selectstack)+1))
                    {	
    	              ##we are backing up. (i.e., ../ was clicked on)

	               last <- Nth(selectstack,Length(selectstack))
                       gselected <- First(last)
                       gPortal.selected <- First(last)

		       ##the selected item may be beyond maxitems.
		       ##in this case, we need to update the offset.
                       if(gPortal.selected>gPortal.maxitems)
                         {
                           gportal.listoffset <- gPortal.selected-Floor(gPortal.maxitems/2)
                         }
   	             ##Remove the last item.
		      if(Length(selectstack)<=1)
                      { 
                       selectStack <- []
                      } else {
                        selectStack <-SubList(selectstack,1,Length(selectstack)-1)
	       	      }
       	   	      gfilelist <- FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),
                                                     gDirChain,First(gFilters))
                      gFlatFileList <- Flatten(gfilelist)

                   }elseif(Length(gDirChain)>Length(selectstack))
                    {
                       ###############################
                       #We opened a new subdirectory.

                        selectStack <- Append(selectstack,[gselected, gOffset])
                  	pselected <- -1
        	        gfilelist <-  FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),
                                                  gDirChain,First(gFilters))
         	        gFlatFileList <- Flatten(gfilelist)
                       gselected <- gPortal.selected

                  } else {
		      gselected <- newselected
                  }

         }}}else{

	 ##update selection stuff.
	 gSelected <- newselected
	 newselected <- gPortal.selected
        }



       gPortal.list <- DirToText(First(gfilelist),Second(gfilelist),   
                             gOffset,gDirChain)


       UpdateScrollbox(gPortal)			     
       ##selected gets updated here;
       DrawScrollbox(gPortal)
       gSelected <- gPortal.selected

       UpdateScreen(win)
   #    Draw()

      }elseif(tmp==5) ##Exit
      {


           PushButton(exit,[0,0])
	   ExitPEBL(gWinDummy,click)

      }elseif(tmp==6) ##hit 'run'
      {
         PushButton(run,[0,0])
        if(not IsPEBLFile(DirListTotext(gDirChain)+Nth(gFlatFileList,gselected)))
         {		
	   PopUpMessageBox("Please select a .pbl file to run",win)
         } else {

	   ##it is a real PEBL test:
       	  if(gnimhdemographics)
    	  {
	      	  GetNIMHDemographics(gsubcode,win,"demographics-log.csv")
          }

	     paramindex <- psetbox.selected

	     if(paramindex==0 or Length(psetbox.list)==0)
	     { 
                 paramset <- "default"
             }else{

  	         paramset <- Nth(psetbox.list,paramindex)
             }


             RunScript(gDirChain,Nth(gFlatFileList,gselected),gfullscreen,
                       glanguage,logfile,gsubcode,gexperimenter,paramset)


             ReadSTDOutStdErr()
             UpdateStdOut(gWinDummy,click)
  	      Draw()

             

          if(gAutoSubCode)
           {
	      ##only do this if it survives a round-trip
               if(ToInteger(gSubcode)+""==gSubcode+"")
                {
 	          gSubCode <- (ToInteger(gSubCode)+1)
                  subjectbox.text <- gSubCode
                }
           }

          }
      }elseif(tmp==7)  ##Change subject code
      {
	   
       ##subject box
	   Show(subboxhighlight)
	   relx <- First(gClick) - (subjectbox.x )
	   rely <- Second(gClick) - (subjectbox.y )

	   subjectbox.cursorpos <-    (GetTextBoxCursorFromClick(subjectbox,relx,rely))

	   Draw()
	   gsubcode <- GetInput(subjectbox,"<return>",1)
           if(ToInteger(gSubcode)+""==gSubcode+"")
              {
 	          gSubCode <- ToInteger(gSubCode)
                  subjectbox.text <- gSubCode
               }

	   Hide(subboxhighlight)
	   
      }elseif(tmp==8)
      {
         ClickCheckBox(fullscreenbox,[0,0])
	 gfullscreen <- fullscreenbox.state

      }elseif(tmp==9)  ##Change experimenter code
      {
       ##experimenter box
	   Show(expboxhighlight)
	   relx <- First(gClick) - (expbox.x )
	   rely <- Second(gClick) - (expbox.y )
	   cursorpos <- GetTextBoxCursorFromClick(expbox,relx,rely)
	   expbox.cursorpos<-cursorpos
	   Draw()
	   experimenter <- GetInput(expbox,"<return>",1)
	   Hide(expboxhighlight)
	   
      }elseif(tmp==10)  ##Change language code
      {

       ##languagebox
	   Show(langboxhighlight)
	   relx <- First(gClick) - (langbox.x )
	   rely <- Second(gClick) - (langbox.y )
	   cursorpos <-  GetTextBoxCursorFromClick(langbox,relx,rely)
	   langbox.cursorpos <- cursorpos 
	   Draw()
	   gLanguage <- GetInput(langbox,"<return>",1)
	   Hide(langboxhighlight)
      }elseif(tmp==2)
      {	   
        ##experiment chain 
       CallFunction(chainbox.clickon,[chainbox,gClick])

      }elseif(tmp==3)
      {
      ##insert chain.

	 PushButton(insertinchain,[0,0])

  	 fname <- Nth(gFlatFileList,gselected)
	 if(IsPEBLFile(fname))
         {
	     paramindex <- psetbox.selected
	     if(paramindex==0 or Length(psetbox.list)==0)
	     { 
                 paramset <- "default"
             }else{
  	         paramset <- Nth(psetbox.list,paramindex)
            }

	    selected <- Max([0,chainbox.selected-1])
            gExpChain <-  Insert(gexpchain,[gDirChain, fname,paramset],selected)

	    
	    chainbox.list<-MakeExpChainList(gexpchain)

            UpdateScrollbox(chainbox)
            DrawScrollbox(chainbox)
         }


      }elseif(tmp==4)
      {

      ##delete
       PushButton(deletestep,[0,0])

       selected <- Max([1,chainbox.selected])
       gExpChain <-  RemoveSubset(gexpchain,[selected])

       chainbox.list<-MakeExpChainList(gexpchain)
       chainbox.selected <- Min([chainbox.selected,chainbox.numitems])
       UpdateScrollbox(chainbox)
       DrawScrollbox(chainbox)


      }elseif(tmp==11)  ##Add to end chain
      {

	 PushButton(addtochain,[0,0])

  	 fname <- Nth(gFlatFileList,gselected)
	 if(IsPEBLFile(fname))
         {
	     paramindex <- psetbox.selected

	     if(paramindex==0 or Length(psetbox.list)==0)
	     { 
                 paramset <- "default"
             }else{
	         paramset <- Nth(psetbox.list,paramindex)
            }

            PushOnEnd(gExpChain,[gDirChain, fname,paramset])
	    chainbox.list<-MakeExpChainList(gexpchain)
	    chainbox.selected <- Length(chainbox.list)
            UpdateScrollbox(chainbox)
            DrawScrollbox(chainbox)
         }

	   
      }elseif(tmp==12)  ##clear chain
      {
	    PushButton(clearchain,[0,0])
            gexpchain <- []        
	    chainbox.list<-MakeExpChainList(gexpchain)
            UpdateScrollbox(chainbox)
            DrawScrollbox(chainbox)

	   
      }elseif(tmp==13)  ##launch chain
      {
         PushButton(launchchain,[0,0])
	 if(gnimhdemographics)
	  {
              GetNIMHDemographics(gSubcode,win,"demographics-log.csv")
          }

          if(gRandomizeChain)
	  {
	    chain <- Shuffle(gexpchain)
	  } else{
            chain <- gexpchain
	  }

   	  loop(i,chain)
          {
  	    dc <- First(i)
            fname <- Second(i)
	    psettext <- Third(i)

            RunScript(dc,fname,gfullscreen,glanguage,logfile,gsubcode,gexperimenter,psettext)
          }
   
      ##Increment subject code after you run
      if(gAutoSubCode)
         {
               if(ToInteger(gSubcode)+""==gSubcode+"")
                {
 	          gSubCode <- (ToNumber(gSubCode)+1)
                  subjectbox.text <- gSubCode
                }

         }

      }elseif(tmp==14)  ##View debug output
      {

         PushButton(viewoutput,[0,0])
         file <- DirListToText(gDirChain)+"stdout.txt"	 
	 if(FileExists(file))
	 {
            LaunchFile(file)
	 }else{
  	   PopupMessageBox("Unable to find file: ["+file+"]",win)
         }
      
      }elseif(tmp==15)  ##View error output
      {
         PushButton(viewerror,[0,0])
         file <- DirListToText(gDirChain)+"stderr.txt"	 
	 if(FileExists(file))
	 {
            LaunchFile(file)
	 }else{
  	   PopupMessageBox("Unable to find file: ["+file+"]",win)
         }

      }elseif(tmp==16)  ##Edit script
      {
         PushButton(edit,[0,0])

	    file <- DirListToText(gDirChain)+Nth(gFlatFileList,gselected)
  	    if(FileExists(file))
	    {
              LaunchFile(gQuote+file+gQuote)
	    }else{
  	      PopupMessageBox("Unable to find file: ["+file+"]",win)
            }

      }elseif(tmp==17)  ##Open Manual
      {   
          PushButton(openmanual,click)
          OpenManual(gWinDummy,click)
        
      }elseif(tmp==18)  ##Launcher Size
      {
	 PushButton(launchsize,click)
	 ChangeLauncherSize(gWinDummy,click)

      }elseif(tmp==19)  ##Visit web
      {
         PushButton(visitweb,click)
         GoToWeb(gWinDummy,click)	   

      }elseif(tmp==20)  ##About
      {
	   PushButton(about,[0,0])
           AboutMessage(gWinDummy,click)



      } elseif(tmp==21) ##handle clickon the description
      {
        ClickOnScrollBox(gDescription,gClick)

      }elseif(tmp==22)
      {
            ClickCheckBox(demobox,[0,0])
            gnimhdemographics <- demobox.state

      }elseif(tmp==23)  ##sAVE CHAIN
      {
         PushButton(savechain,[0,0])
         Saveconfig(gconfigname)
         PopupMessageBox("Configuration file:" + gConfigName+ " saved to disk",win)
       } elseif(tmp==36)
      {  ##delete selected chain.
      
       PushButton(deletechain,[0,0])

       if(FileExists(gConfigName))
        {
          DeleteFile(gConfigName)
        }
 
         opts <- GetConfigFiles()
	  PushOnEnd(opts,gLoadChainText)
	  UpdatePullDown(loadchain,opts)
	  selected <-   Min([loadchain.selected,loadchain.numitems])
          gConfigName<-Nth(loadchain.list,selected)



     ##now, gconfigname is re-selected.
    ReadConfigFile(gConfigName)
    if(not FileExists(gConfigName))
       {
         Saveconfig(gConfigname)
       }

   ##try to select gConfigName:
   index <- 1
   loop(i,loadchain.list)
   {

    if(i == gConfigName)
     {
       loadchain.selected <- index
       DrawPulldown(loadchain)
     }
    index <- index + 1 
   }


         ##fullscreen may have been changed when config was read in.

	SetCheckBox(fullscreenbox,gFullScreen)
        SetCheckBox(demobox,gNIMHDemographics)
        SetCheckBox(randomizechainBox,gRandomizeChain)

	title <- chainbox.header
	title.text <- gExpChainText+gConfigName
         chainbox.list<-MakeExpChainList(gexpchain)
         UpdateScrollbox(chainbox)
         DrawScrollbox(chainbox)
 
      }elseif(tmp==24)  ##loadchain pulldown box
      {
          opts <- GetConfigFiles()
	  PushOnEnd(opts,gLoadChainText)
	  UpdatePullDown(loadchain,opts)
	  selected <-   Pulldown(loadchain,gClick)
	  if(selected == loadchain.numitems)
          {
            configname <- PopUpEntryBox(gConfigNameText,win,gClick)
	    if(not IsConfigFile(configname))
	     {
                configname <- configname + ".config"
	     }
            gConfigName<-configname

	    PushOnEnd(opts,gConfigname)
	    UpdatePulldown(loadchain,opts)	     
          }else{
            gConfigName <- Nth(loadchain.list,selected)
          }

         ##now, gconfigname is selected.
        ReadConfigFile(gConfigName)
        if(not FileExists(gConfigName))
        {
          Saveconfig(gConfigname)
        }

   ##try to select gConfigName:
   index <- 1
   loop(i,loadchain.list)
   {

    if(i == gConfigName)
     {
       loadchain.selected <- index
       DrawPulldown(loadchain)
     }
    index <- index + 1 
   }


         ##fullscreen may have been changed when config was read in.

	SetCheckBox(fullscreenbox,gFullScreen)
        SetCheckBox(demobox,gNIMHDemographics)
        SetCheckBox(randomizechainBox,gRandomizeChain)
	UpdateScreenResPulldown(screenselection)
        DrawPulldown(screenselection)

	title <- chainbox.header
	title.text <- gExpChainText+gConfigName

         chainbox.list<-MakeExpChainList(gexpchain)
         UpdateScrollbox(chainbox)
         DrawScrollbox(chainbox)
         

      }elseif(tmp==25)  ##Visit wiki
      {
        PushButton(wiki,[0,0])
        VisitWiki(gWinDummy,click)
        
      } elseif(tmp==26)
      { 
        ##increment!
          if(ToInteger(gSubcode)+""==gSubcode+"")
              {
                  gSubCode <- (ToNumber(gSubCode)+1)
                  subjectbox.text <- gSubCode
               }
   
	    PushButton(subplusbutton,[0,0])

      } elseif(tmp==27)
      { 

       ##Command-line box
	   relx <- First(gClick) - (clobox.x )
	   rely <- Second(gClick) - (clobox.y )

	   clobox.cursorpos <-  GetTextBoxCursorFromClick(clobox,relx,rely)
	   Draw()
	   gCommandLineText <- GetInput(clobox,"<return>",1)
	   Hide(cloboxhighlight)

      } elseif(tmp==28)
      { 

       PushButton(filter,[0,0])
       gFilters <- Rotate(gFilters,1)
       filter    <- MakeButton(First(gFilters),filter.x,filter.y,win,172)
       gfilelist <-  FilterDir(GetDirectoryListing(DirlistToText(gDirChain)),gDirChain,First(gFilters))
       gFlatFileList <- Flatten(gfilelist)

       gPortal.list <-  DirToText(First(gfilelist),Second(gfilelist),   
                             gOffset,gDirChain)

       UpdateScrollbox(gPortal)			     
       DrawScrollbox(gPortal)
       UpdateScreen(win)



      }elseif(tmp==29)  ##29 == donate 
       {		
         PushButton(donate,[0,0])
	 Launchfile("http://www.superiorideas.org/node/139")

if(0)
{
	 fname <-DirListToText(gDirChain)+ Nth(gFlatFileList,gselected)

		 if(IsDataFile(fname))
         {

			bg1 <- Rectangle(550,400,700,800,MakeColor("black"),1)
			bg <- Rectangle(750,400,490,790,MakeColor("grey"),1)

			AddObject(bg1,win)			
			AddObject(bg,win)


			header <- EasyLabel("Transmit data file to server.",750,20,win,30)
			message <- EasyLabel("Enter IP address or hostname:",750,60,win,22)
			message2 <- EasyLabel("",750,80,win,22)
			
			entry <- EasyTextBox(gDefaultHostName,550,100,win,16,400,20)
                        address <- GetInput(entry,"<return>")
			gDefaultHostName <- entry.text
			Draw()



			text <- FileReadText(fname)

			message.text <-"Opening connection to host: "+address
			Draw()

			starttime <- GetTime()
			network <- 0
			message2.text <- "waiting"

			secs <- 0

			
			while(network==0 and secs < 10)
 			{

 	                   network <- ConnectToHost(address,4444)			     
			   time <- Floor((GetTime()-starttime)/1000)
			   
			  
			   if(time > secs)
			   {

			     secs <- time
                              message2.text <- message2.text + "."
			     Draw()
                            }
			}			

			if(network==0)
			{
			   message.text <- "Unable to make connection to host."
			   message2.text <- "Press any key to return."
			   Draw()
			} else {

			   message.text <- "Connected to host. Sending data."
			   Draw()

			    SendFile(network,fname,"USER"+RandomDiscrete(10000),message)
			    message.text <-  "Data sent."
 	  	 	    message2.text <- "Press any key to return."
             	            CloseNetworkConnection(network)
			}

			Draw()
			RemoveObject(bg1,win)
			RemoveObject(bg,win)
			RemoveObject(entry,win)
			RemoveObject(message,win)
			RemoveObject(message2,win)
			RemoveObject(header,win)

			WaitForAnyKeyPress()
          }


      	   Draw()

         } else {
           PopupMessageBox("Not implemented",win)
         }

		 
       } elseif(tmp==30) ##write review
        {
 	     PushButton(review,[0,0])
	     Launchfile("http://sourceforge.net/projects/pebl/reviews/")
	   
       }elseif(tmp==31)  ##Change screen resolution.
         {       



          resolutions <- UpdateScreenResPulldown(screenselection)
	  PullDown(screenselection,gClick)
	  Draw()
        choice <- screenselection.selected ##index chosen.

        ##choice could be any one of the first N
	##options, 'current', 'custom'

       if(choice ==screenselection.numitems)
	   {
	     ##get custom screen size:

	      xy <- [screenselection.x+screenselection.width/2,
                      screenselection.y+screenselection.height/2]
              width <- ToNumber(PopUpEntryBox(gGetWidthText,win,xy))
              height <- ToNumber(PopUpEntryBox(gGetHeightText,win,xy))
	      gCustomScreenRes <-  width+"x"+height
              UpdateScreenResPulldown(screenselection)
	      ##reset to choice

	      screenselection.selected <- screenselection.numitems-1

	      DrawPulldown(screenselection)	      
	      gScreenRes <- gCustomScreenRes	      
	      Draw()

	   } elseif(Nth(screenselection.list,choice) == gCurrent)
	   {
            ##Use the current screen resolution:
	    gScreenRes <- gCurrent

	   } elseif(Nth(screenselection.list,choice)== (gCustomText+gCustomScreenRes)){
	   gScreenRes <- gCustomScreenRes

           }else {
	      #Use the specified resolution.
	      res <- Nth(resolutions,choice)
              gScreenRes <- First(res)+"x"+Second(res)
	   }

         

     }elseif(tmp==32)
      {
       ClickCheckBox(randomizechainbox,[0,0])
       gRandomizeChain <- randomizechainbox.state

      }elseif(tmp==33)
      {
       ##Set/edit parameters. 
       PushButton(params,[0,0])

        paramindex <- psetbox.selected
        if(paramindex==0 or Length(psetbox.list)==0)
         {
             paramset <- "default"
          }else{
             paramset <- Nth(psetbox.list,paramindex)
          }
          file <-  SetParameters(gDirChain,Nth(gFlatFileList,
                                      gselected),win,paramset)

       ## we need to update psetbox and select file if it exists.
          parfiles <- GetParFiles()   

          UpdatePulldown(psetbox,parfiles)

	  ##find out best index.
	  if(Length(parfiles)>0)
          {
	  loop(i, Sequence(1, psetbox.numitems,1))
	  {

	   if(Nth(psetbox.list,i)==file)
           {
             psetbox.selected <- i
	     break
           }
	  } 
          }
          pselected <- psetbox.selected
	  DrawPulldown(psetbox)

     } elseif(tmp==34)
      {
        ##Combine data dialog, which is really a separate PEBL program.
        PushButton(combineData,[0,0])
        CombineDataDialog(gDirChain,Nth(gFlatFileList,gselected),logfile)
      }elseif(tmp==35)
      {
       ##get the parameter files we want.

       if(Length(parfiles)>1)
       {
        Pulldown(psetbox,gClick)
        pselected <- psetbox.selected
       }


      }


     Draw()

   }


}

define CombineDataDialog(dirChain,filename,logfile)
{
 ##this would work, but it runs blocking the current app. so reconstruct runscript.
##  RunScript(dirchain, "combinedatafiles.pbl",0,gLanguage, logfile,0,"","")
## gDebug <- 1
   Print(filename)
   type <- GetSystemType()
   if(type== "LINUX" or type=="OSX")
   {
     sep <- " ; "
   } else {
     sep <- " & "
   }
   
  ##On windows, should the launcher run from a PEBL subdirectory rather than C:\Program Files\pebl
   if(gUseReloc)
     {

        sep <- CR(1)
        gPEBLName <- "\bin\pebl.exe"  ##The relative location should be bin\pebl.exe
  	    callstring <- "set ABSPATH=%CD%"+sep+"cd " + DirListToText(dirchain) + sep + gQuote+"%ABSPATH%\PEBL" +gPEBLName +gQuote + " " +  gQuote + "combinedatafiles.pbl"+gQuote

     }else {
         
  	      callstring <- "cd " + DirListToText(dirChain) + sep  + gPEBLName + " "  +gQuote+ "combinedatafiles.pbl"+gQuote 

      }

     callstring <- callstring + " --language " + glanguage 

     if(type =="LINUX" or type == "OSX" or type == "WINDOWS")
        {
          if(gDebug)
	    {
             if(type == "WINDOWS")
	        {
  		      callstring <- callstring + "> combine.out.txt 2> combine.err.txt "
		    }
             }

	   if(type=="LINUX" or type=="OSX")
             {

                callstring <- callstring + " > stdout.txt 2> stderr.txt "
             }
        }

	##be sure to run in background, if possible.
  callstring <- callstring + "&"  ##Run in background
  if(gUseReloc)
      {
         runfile <- FileOpenOverWrite("tmp.bat")
         FilePrint(runfile,callstring)
         FileClose(runfile)
         SystemCall("tmp.bat","")

      }else{
         #PopUpMessageBox(callstring,gwin)
         Print(callstring)
         Print(SystemCall(callstring,""))
      }
}




##This is a hard-coded filter;
##it will only return .pbl files and directories.
define FilterDir(inlist,path,type)
{

  pathhead <- DirListTotext(path)
  tmpdir <- []
  tmppbl <- []
  loop(i, inlist)
  {

    if(IsDirectory(pathhead+i))
      {
         tmpdir <- Append(tmpdir,i)
      }else{
	  
       if(type=="*.pbl")
       {
       if(IsPEBLFile(i))
        {
            tmppbl <- Append(tmppbl,i)
        }
       } elseif(type=="data files") {
         if(IsDataFile(i))
         {
	     tmppbl <- Append(tmppbl,i)
         }
	        
      }elseif(type=="*.*"){
	   ##no filter:
           tmppbl <- Append(tmppbl,i)
       }elseif(type=="*.png")
       {
         if(IsPNGFile(i))
	 {
           tmppbl <- Append(tmppbl,i)
	 }
       }elseif(type=="*.par")
       {
        if(IsPARFile(i))
	{
          PushOnEnd(tmppbl,i)
	}
       }elseif(type=="*.config")
       {
         if( IsConfigFile(i))
	 {
	   PushOnEnd(tmppbl,i)
	 }
       }elseif(type=="*.about.txt")
       {
         if(IsAboutFile(i))
         {
          PushOnEnd(tmppbl,i)
         }

       }
     }
  }
  return [Sort(tmpdir),Sort(tmppbl)]

}



define DirToText(dirlist,filelist,offset,path)
{ 

  pathhead <- DirListTotext(path)

  tmp <- []
  loop(i,dirlist)
  {
     PushOnEnd(tmp,  i +"\")
  }

  loop(i,filelist)
  {
    PushOnEnd(tmp,  i )
  }

  ##this crashes here sometimes here, let's be sure we access part of the list that we can.
  offset <- Max([0,offset])
  list <- SubList(tmp,offset+1,Length(tmp))
  return list
}


define AppendDirList(dirlist,dir)
{

 if(dir == ".")
   {
     dirlist <- dirlist
   }elseif(not dir == "..")   
   {
      dirlist <- Append(dirlist,dir)
   } else {
      if((not Last(dirlist) == ".") and
	     (not Last(dirlist) == ".."))
	  {
	      dirlist <- SubList(dirlist,1,Length(dirlist)-1)
      } else {
	      dirlist <- Append(dirlist,dir)
      }
   }

   return dirlist
}


##appends a set of nested directories into a path.
define DirlistToText(list)
{
  tmp <- ""
  if(GetSystemType()=="WINDOWS")
    {
	   sep <- "\"
	} else {
	   sep <- "/"

	}
  loop(i,list)
  {		 
     tmp <- tmp + i+ sep
  }
  return tmp
}


##This saves a table (nested list) to a file
##it is used to save the .config files
define  FileSaveTable(table,filename)
{
   ##Not clear why we are using global here rather than the passed-in value.

   outfile <- FileOpenOverwrite(filename)  ##Overwrite whatever we ave, without checking for it.
   loop(i,table)
    {
       FilePrint_(outfile, First(i) + ",")

	   if(IsList(Second(i)))
        {
		   sep <- ""
		   loop(j,Second(i))
           {
		      FilePrint_(outfile,sep+j)
			  sep <- ","
           }
		   FilePrint(outfile,"")
        } else {
		  FilePrint(outfile,Second(i))
        }
    }
  FileClose(outfile)
}


##This makes the text to put in the expchain box.
define MakeExpChainList(expchain)
{
  tmp <- []
  loop(i,expchain)
    {
 	PushOnEnd( tmp,DirlistToText(First(i))+Second(i) + " --pfile "+gQuote+Third(i) +gQuote)
    }
  return tmp	
}


define RunScript(dirChain,filename,fullscreen,language,logfile,subcode,experimenter,pset)
{
  ##Additional command-line parameters that should be hardcoded:
  ## put --driver  --video, etc. here. 
  gCommandLineAdd <- " " + gCommandLineText

   type <- GetSystemType()
   if(type== "LINUX" or type=="OSX")
   {
     sep <- " ; "
   } else {
     sep <- " & "
   }
   
  ##On windows, should the launcher run from a PEBL subdirectory rather than C:\Program Files\pebl
   if(gUseReloc)
     {
       Print(gPEBLName)
        sep <- CR(1)
        gPEBLName <- "\bin\pebl.exe"  ##The relative location should be bin\pebl.exe
		callstring <- "set ABSPATH=%CD%"+sep+"cd " + DirListToText(dirchain) + sep + gQuote+"%ABSPATH%\PEBL\" +gPEBLName +gQuote+ " " +filename + " -s " + subcode
    		 ##callstring <- "set ABSPATH=%CD%"+gPEBLname+ CR(1)+ " cd "+DirListToText(dirchain)+CR(1)+gQuote+"%ABSPATH%"+gquote + " " + filename +" "  

     }else {
         
    		 callstring <- "cd " + gQuote+DirListToText(dirChain)+gQuote + sep  +
                                gPEBLName + " "  +gQuote+filename+gQuote + " -s " + subcode
##    		 callstring <-  gPEBLName + " "  +gQuote+filename+gQuote + " -s " + subcode


      }


      ##Get the current screen size to use for launching experiments,
      ##the preferred size should be set or read in from config file.
      ## if we are not fullscreen.
     if(gScreenRes == gCurrent)
      {
        gScreenResLine <- ""
      }else  {
        gScreenResLine <- "--display " + gScreenRes
      }


       if(fullscreen)
         {
	     callstring <- callstring + " --fullscreen " + gScreenResLine

         }else{
              ##If not fullscreen, use something sligtly smaller
              ##to make way for toolbars etc.
             callstring <- callstring + " " + gScreenResLine
          }

	  if(not pset == "")
           {
             callstring <- callstring + " --pfile " +gQuote+ pset+gQuote
           }

	    callstring <- callstring + " --language " + language  + " " + gCommandLineAdd
  

          if(type =="LINUX" or type == "OSX" or type == "WINDOWS")
           {
            if(gDebug)
  	       {
		  if(type == "WINDOWS")
		    {
			   callstring <- callstring + sep+"pause"
		    }
                }
               callstring <- callstring + " > stdout.txt 2> stderr.txt"

           }

         FilePrint(logfile,TimeStamp() + "," + DirListToText(dirChain)+ filename+","+GetPEBLVersion() + "," + experimenter + "," + subcode + "," +"fullscreen:["+fullscreen+"],"+ language + "," + callstring+ ","+"STARTED")

         #### Run the experiment!!!!
         Print("Executing : [" + callstring + "]")

  if(gUseReloc)
      {

          runfile <- FileOpenOverWrite("tmp.bat")
     ##     FilePrint(runfile,callstring+sep+"pause") ##Use for debugging purposes.
          FilePrint(runfile,callstring)
          FileClose(runfile)
          SystemCall("tmp.bat","")
      }else{
         Print(SystemCall(callstring,""))
      }

         FilePrint(logfile,TimeStamp() + "," + DirListToText(gDirChain)+filename+","+GetPEBLVersion() +
		 "," + experimenter + "," + subcode + "," +"fullscreen:["+fullscreen+"],"+ language + "," + callstring+ ","+"FINISHED")

}



define IsPEBLFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
            if(SubString(fname,len-3,len)==".pbl")
	     			{
					  returnval <-  1
                    }

          }
   return returnval
}

define IsparFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
            if(SubString(fname,len-3,len)==".par")
		{
			  returnval <-  1
                 }

          }
   return returnval
}


define IsConfigFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>6)	
      {
       if(SubString(fname,len-6,len)==".config")
	  {
           returnval <-  1
          }

          }
   return returnval
}

define IsAboutFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>9)	
      {
       if(SubString(fname,len-9,len)==".about.txt")
	  {
           returnval <-  1
          }

          }
   return returnval
}

define IsDataFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
		   tmp <- SubString(fname,len-3,len)
            if(tmp==".csv" or tmp == ".dat" or tmp == ".txt") 
    			{
					  returnval <-  1
                }

          }
   return returnval
}

define IsPNGFile(fname)
{

  returnval <- 0
  len <- StringLength(fname)	
  if(len>4)	
           {
           if(Lowercase(SubString(fname,len-3,len))==".png")
	     	{
					  returnval <-  1
                }

          }
   return returnval
}





define ReadConfigFile(configname)
{

##This reads in some configuration stuff from the current
## config file.

   if(FileExists(configName))
      {
           config <- (ReadCSV(gConfigName))
	   
	   ##read in the keys--first characters.
	   keys <- []
	   loop(i,config)
	   {
	     keys<- Append(keys,First(i))
           }

	   tmpres <- First(gScreenResInitial)+"x"+Second(gScreenResInitial)
           ##This is the text description of the screenres.
	   gScreenRes <- GetConfig("screenres",keys,config,tmpres)
	   ##we need to set the pulldown default here.
	   
	   gfullscreen <- ToNumber(GetConfig("fullscreen",keys,config,0))
	   gnimhdemographics <- ToNumber(GetConfig("nimhdemo",keys,config,0))
	   gsubcode    <- GetConfig("subcode",keys,config,"0")

	   if(gAutoSubCode)
            {
             if(ToInteger(gSubCode)+""==gSubcode+"")
             {
  	         gSubCode <- (ToInteger(gSubCode)+1)
             }
            }


	   gDefaultHostName <- GetConfig("ipaddress",keys,config,"localhost")
	   gCommandLineText <- GetConfig("commandline",keys,config,"")
	   gexperimenter <-GetConfig("experimenter",keys,config,"default")
	   glanguage <-GetConfig("language",keys,config,"en")
	   gRandomizeChain <- ToNumber(GetConfig("randomizechain",keys,config,0))
   	   gexpchain <- []         ##sequence of experiments to run
   	   ##Get all config entries named 'expchain'
	   chains <- Filter(config,Match(keys,"EXPCHAIN"))
	   loop(i,chains)
            {
              PushOnEnd(gexpchain, 
                 [SubList(i,4,Length(i)),Second(i),Third(i)])
            }  

      } else {
      ##We don't have a config file.
        gDefaultHostName <- "localhost"
        gCommandLineText <- ""
        gfullscreen <- 0
        gsubcode <- "1"
        gexperimenter <- "default"
        glanguage <- "en"
        gexpchain <- []         ##sequence of experiments to run
	    gnimhdemographics <- 0
        gScreenRes <-  First(gScreenResInitial)+"x"+Second(gScreenResInitial)
	    gRandomizeChain <- 0
      }

}

define Saveconfig(configname)
{

    ##save settings on exit.
	out <- [["fullscreen",gfullscreen],
                ["subcode",gsubcode],
                ["experimenter",gexperimenter],
	        ["language",glanguage],
	        ["nimhdemo",gnimhdemographics],
	        ["commandline",gCommandLineText],
	        ["ipaddress",gDefaultHostName],
 		    ["screenres",gScreenRes],
		    ["randomizechain",gRandomizeChain]
               ]
            

	  ##each element of gExpChain has three parts:
	  ##1. a list containing the path chain (variable length)
          ##2. the script name
 	  ##3. the parameter file (could be default)


	  loop(i,gexpchain)
          {

	     ##we need to save 1. script name, 2. parameter file, 3 path
	     ilist <- Flatten([Second(i),Third(i),First(i)])
	     PushOnEnd(out,["EXPCHAIN",ilist])
           }
      FileSaveTable(out,configname)
}




define GetStrings(lang)
{
       gRunText <- "Run selected test"
       gEditParams <- "Edit"

	gOpenText <- "Open/Edit Selected"
	gExitText <- "EXIT"
	gViewDebugText <- "Open debug output"
        gViewErrorText <- "Open error output"
        gCombineDataText <-"Combine data"
        gAddToChainText <- "Append"
	gClearChainText <- "Clear Chain"
	gInsertChainText <- "Insert"
	gDeleteStepText <- "Delete step"

	gSaveChainText <- "Save Chain"
	gDeleteChainText <- "Delete Chain"
	gLoadChainText <- "Make New Chain"
        gRandomizeChainText <- "Randomize Chain"

	gOpenManualText <- "Open Manual"
	gAboutLabelText <- "About"
	gSizeText <- "Size: "
	gwebtext <- "Visit Website"
	gWikiText <- "Wiki"
	gLaunchChainText <- "Launch Chain"
    gNoDesc <- "Please cite PEBL if you use it:"+CR(1)+"Mueller, S. T., & Piper, B. J. (2014). The Psychology Experiment Building Language (PEBL) and PEBL Test Battery. Journal of neuroscience methods, 222, 250259."
    gPEBLTitle <- "PEBL Launcher for "
    gPartCode <- "Participant Code:"
    gCustomText <- "Custom:"
    gCurrent <- "Current"
    gGetWidthText <- "Enter custom width in pixels:"
    gGetHeightText <- "Enter custom height in pixels:"
	gExperCode <- "Experimenter:"
	gCommandLineOptions <- "Command line options:"
	gParameterLabel <- "Parameters:"
	gLangcode  <- "Language:"
	gFulltext <- "Fullscreen"
	gCollectDemoText <- "Collect demographics"
    gScreenResLabel <- "Screen resolution:"

    gExpChainText <- "Experiment Chain:"
    gConfigNameText <- "Enter name of new chain config file."
    gRelaunchMessage <- "Please exit the launcher and restart."
    gChooseScreenText <- "Choose screen resolution to use"
    gAboutText <-"PEBL is a system for creating and running psychology experiments.  It is developed by Shane T Mueller, Ph.D., and includes more than 50 standard psychology lab experiments.  You can use PEBL to create your own tests or modify previous ones FREE OF CHARGE. Find out more at http://pebl.sf.net

This launcher is written in PEBL itself, allowing a fairly uniform launcher on all platforms. Only .pbl  files and directories are shown in the file window--use your file manager to get the data after your experiment is complete. Click on a directory that has been selected to open it.  Add scripts to the experiment chain window to run a sequence of experiment in a row, all using the same subject code.  

 *The file [PEBLLaunch-log.txt] contains a log of every experiment launched from the launcher.
 *Debug output from each script (using the Print() command) is saved in the file [stdout.txt] file in a script's directory.
 *Error and automatic messages from each script are saved in the file [stderr.txt] in a script's directory."



  lang <- Uppercase(lang)
  if(lang == "ES")
   {
    gRunText <- "Ejecutar script seleccionado"
    gOpenText <- "Abre"
    gExitText <- "EXIT"
    gViewDebugText <- "Ver la salida de depuracin"
    gViewErrorText <- "Ver la salida de error"
    gCombineDataText <-"Combinar data"
    gAddToChainText <- "Aadir a la cadena"
    gClearChainText <- "Borrar la cadena"
    gSaveChainText <- "Guardar la cadena"
    gLoadChainText <- "Cadena de carga nuevo"
    gOpenManualText <- "Abrir Manual"
    gAboutLabelText <- "Acerca de"
    gSizeText <-"Size: "
    gwebtext <- "Pgina Web"
    gWikiText <- "Wiki"
    gLaunchChainText <- "Lanzamiento de la cadena"
    gNoDesc <- "La descripcin no encontrado"
    gPEBLTitle <- "PEBL Launcher para "
    gPartCode <- "Cdigo de Participante:"
    gExperCode <- "Experimentador"
	gCommandLineOptions <- "Command line options:"
    gLangcode <- "Idioma:"
    gFulltext <- "Pantalla Completa"
    gScreenResLabel <- "Screen resolution:"
    gCustomText <- "Custom:"
    gCurrent <- "Current"
    gCollectDemoText <- "Recoger datos demogrficos?"
    gChooseScreenText <- "Choose screen resolution to use"
    gExpChainText <- "Experimento de la cadena:"
    gConfigNameText <- "nombre de configuracin?"
    gRelaunchMessage <- "Please exit the launcher and restart."
    gAboutText <- "Spanish Translation courtesy automated translation. PEBL es un sistema de creacin y ejecucin de experimentos de psicologa Es desarrollado por Shane T Mueller, Ph.D., e incluye ms de 50 experimentos de laboratorio estndar de la psicologa Puede utilizar PEBL para crear sus propias pruebas o modificar la anterior. los GRATUITO. Ms informacin en http://pebl.sf.net

Este lanzamiento est escrito en PEBL s mismo, permitiendo que un lanzador bastante uniforme en todas las plataformas. . Slo los archivos y directorios pbl se muestran en la ventana del archivo - utilizar su gestor de archivos para obtener los datos despus de la prueba se ha completado. Haga clic en un directorio que ha sido seleccionada para abrirlo. Agregar secuencias de comandos a la ventana de la cadena de experimento para ejecutar una secuencia de experimentos en una fila, todas ellas con el cdigo mismo tema.

 * El archivo [PEBLLaunch-log.txt] contiene un registro de todos los experimentos en marcha del lanzador.
 * La salida de depuracin de cada secuencia de comandos (usando la Print() comando) se guarda en el archivo el archivo [stdout.txt] en el directorio de un script.
 * Mensajes de error y automtica de cada secuencia de comandos se guardan en el archivo [stderr.txt] en el directorio de una secuencia de comandos."

   }
}


## This should be received with ReceiveText(network)
define SendText(network,text)
{
   len <- StringLength(text)
   
#   Print("Sending: [" + ZeroPad(len,10)+"]")

   SendData(network,ZeroPad(len,10))
   SendData(network,text)
   
}


define ReceiveText(network)
{
	len <- ToNumber(GetData(network,10))
	text <- GetData(network,len)
	return text
}


## a robust version of lookup:
define GetConfig(key, keys, database,empty)
{
   line <- Lookup(key,keys,database)
   if(Length(line)==0)
   {
    ret <- empty
   }else{
   ret <- Second(line)
   }
  return ret
}






## This sends a file using a direct tcp/ip connection, using
## a special file protocol.
##

define SendFile(network,filename,id,label)
{ 

   text <- FileReadText(filename)
   length <- StringLength(text)+""
   
   if(StringLength(length)>16)
   {
     SignalFatalError("Cannot send a file this long:"+length)
   }


   message <-  Format(id,32)+Format(length,16) + text
   label.text <-"Attempting to send data to server (up to 10 secs)"
   Draw()
   Wait(500)
   success <- SendData(network,message)
   if(success)
   {
      label.text <- "Succeeded at sending data"
      Draw()
      Wait(500)
   } else {
      label.text <- "Failed to send data.  Please try again later or send data files directly. Press any key to begin."
      Draw()
      WaitForAnyKeyPress()
   }
   return success
}

##  This is the installer code that gets run if the right Documents 
##  directory does not exist.
##  Otherwise, the normal launcher will run.
##
define RunFirstTime(p)
{
    Print("running first time inside")
    Print(p)
   if(Length(p)>1)
     {
	
   	 resources <- Nth(p,1)
     ##Print("Resources:" + resources)
	 targetdir <- Second(p)
	 home <- targetdir

	} else {
    	 Print("using default resources")
   	    if(GetSystemType()=="OSX")
		  {
             Print(p)
   	         resources <- Nth(p,1)
             Print("Resources:" + resources)
	         
	         #resources <- "/Applications/pebl.app/Contents/Resources"

  		  } elseif(GetSystemType()=="WINDOWS")
                    {
                      ##Check here for robustness.
            if (FileExists("%ProgramFiles(x86)%"))
 		     {
		       resources <- "%ProgramFiles(x86)%\\PEBL"
		      } else {

		       resources <- "%ProgramFiles%\\PEBL"
		      }

		  }else {
		   ##linux.  this is hardcoded right now, but should be
		   ##made more portable:
		   resources <- "/usr/share/pebl"
		   if(not FileExists(resources))
		   {
  		     resources <- "/usr/local/share/pebl"
		   }

		   if(not FileExists(resources))
		   {
  		     resources <- "../"
		   }
		   

		   if(not FileExists(resources))
		   {
 		     SignalfatalError("Unable to find installed PEBL resource directory")
		   }
		   
                  }

	 }

	if(0)
	 {
     ##We possibly need to hard-code this.
   
       if(GetSystemType()=="OSX")
	  {
           resources <- "/Applications/pebl.app/Contents/Resources"
      }
     }
	 
	 targetDir <- "pebl-exp."+gPEBLVersion
	
	
    gVideoWidth <- 800
    gVideoHeight <- 500
    gwin <- MakeWindow("white")
    gSleepEasy <- 1
       
   head1 <- EasyLabel(GetPEBLVersion() + " for " +GetSystemType(),gVideoWidth/2,50,gwin,22)


   pebl <- MakeImage("pebl.png")
   AddObject(pebl,gWin)
   Move(pebl,gVideoWidth/2,125)
   message0 <- "Resources at: ["+resources+"]" +CR(1)+ "HOME at: " + ghome + CR(1)
   message1 <- message0+"By default, PEBL tries to look for files in ["+ghome+"]" + CR(2) +
   "Would you like to create the directory and install some basic experiment scripts?"



   inst <- EasyTextBox(message1,
                        25,200,gwin,15,gVideoWidth-50,130)


if(1)
 {
   yes <- EasyLabel("YES", gVideoWidth/2-50,350,gWin,40)
   no <-  EasyLabel("NO",  gVideoWidth/2+50,350,gWin,40)
   Draw()
   copy <- WaitForClickOnTarget([yes,no],[1,0])
   Hide(yes)
   Hide(no)
 
 
    Draw()
 
	if(copy)
     {
	 if(GetSystemType()=="OSX")
	  {
	  SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion,"")
	#  SystemCall("cp "+resources+"/fileselect.pbl $HOME/Documents/pebl-exp."+gPEBLVersion+"/","")
	  SystemCall("cp -R "+resources+"/battery/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/battery","")
	  SystemCall("cp -R "+resources+"/demo/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/demo ","")
          SystemCall("cp -R "+resources+"/experiments/* $HOME/Documents/pebl-exp."+gPEBLVersion+"/demo ","")      
          SystemCall("cp "+resources+"/PEBLManual"+gPEBLVersion+".pdf $HOME/Documents/pebl-exp."+gPEBLVersion+"/","")



###########copy files on windows
       }elseif(GetSystemType()=="WINDOWS"){


      inst.text <- "<"; Draw()
      dest <- ghome
      if(FileExists(ghome+"\Documents"))
	    {
		   doc <- "\Documents"
	    } elseif (FileExists(ghome+"\My Documents"))
		{
		   doc <- "\My Documents"
		} else {
		    #user-selected?
		    doc <- "\My Documents"
		}
		
            dest <- ghome+ doc + "\pebl-exp."+gPEBLVersion 
 	    #SystemCall("md " + dest +" >> "gHome+"\pebl_install_log.txt","")

            MakeDirectory(dest)
	    MakeDirectory(dest+"\battery")
	    MakeDirectory(dest+"\demo")

	 ##copy test battery:
          Print("xcopy "+gQuote+resources+"\battery\*"+gQuote+" "+gQuote+dest+"\battery"+gQuote+" /e")
 	  SystemCall("xcopy "+gQuote+resources+"\battery\*"+gQuote+" "+gQuote+dest+"\battery"+gQuote+" /e","")
        ##Copy demo:
        Print("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+gQuote+dest+"\demo"+gQuote+" /e")
        SystemCall("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+gQuote+dest+"\demo"+gQuote+" /e","")
        
        #Print("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+dest+"\demo"+" /e")
        #SystemCall("xcopy "+gQuote+resources+"\demo\*"+gQuote+" "+dest+"\demo"+" /e","")

        ##Copy doc:
        Print("copy "+gQuote+resources+"\doc\PEBLManual"+gPEBLVersion+".pdf"+gQuote+" "+gQuote+dest+gQuote)
        SystemCall("copy "+gQuote+resources+"\doc\PEBLManual"+gPEBLVersion+".pdf"+gQuote+" "+gQuote+dest+gQuote,"")
		
	###########copy files on linux
       }elseif(GetSystemType()=="LINUX"){

      resources <- "../"
      inst.text <- "<"; Draw()
      dest <- ghome
      if(FileExists(ghome+"/Documents"))
       {
	   doc <- "/Documents"
       } 
	
            dest <- ghome+ doc + "\pebl-exp."+gPEBLVersion
 	    #SystemCall("md " + dest +" >> "gHome+"\pebl_install_log.txt","")
            MakeDirectory(dest)
	    MakeDirectory(dest+"\battery")
	    MakeDirectory(dest+"\demo")

      inst.text <- "<"; Draw()
	  SystemCall("mkdir $HOME/Documents/pebl-exp."+gPEBLVersion+" > ~/tmp.txt","")
	  SystemCall("cp -R "+resources+"/battery/ $HOME/Documents/pebl-exp."+gPEBLVersion+"/battery >> ~/tmp.txt","")
		
	  }


		
	   inst.text <- "Files copied. Next time you run PEBL, it will automatically run the launcher and show you the scripts in Documents/pebl-exp."+gPEBLVersion+"." + CR(1) +
	    "Click the window to exit."
	  
	 } else {

       inst.text <- "Click window to exit."
	}
 }
	 Draw()
   WaitForDownClick()
   
   
}


## This handles setting parameters for a selected script file.
##
define SetParameters(dirChain,scriptname,win,parname)
{

##  Print("setting praameters with:" + parname)
  path <- DirListToText(dirchain) +"params/"
  schema <- path+scriptname+".schema"
 
  ##this is what will be used for the default param file:
  if(parname=="default")
  {
    paramsfile <- path+scriptname
    parname <- scriptname
  }else{
    paramsfile <- path + parname
  }

   if(not SubString(paramsfile,StringLength(paramsfile)-3,4)==".par")
   {
     parname <- parname + ".par"
     paramsfile <- paramsfile + ".par"
   }

  fail <- 0

  if((not FileExists(schema)))
   { 
      if(IsPEBLFile(scriptname))
         {
            PopupMessageBox("Schema file does not exist for script ["+scriptname+"]. Schema files are saved in the params\ subdirectory of the script's directory.  Most likely, the parameters of ["+scriptname+"] cannot be set using this interface.",win)
         }else{
            PopupMessageBox("To set parameters, select a .pbl file first. ["+scriptname+"] is not a PEBL script ending with .pbl",win)
         }


     fail <- 1
   }

 if(not fail)
  {
 
  ##Create background over current window.
  rect <- Rectangle(gVideoWidth/2,gVideoHeight/2,gVideoWidth,gVideoheight,MakeColor("grey80"),1)
  AddObject(rect,win)

  header <- EasyLabel("Editing parameters for "+path+scriptname,gVideoWidth/2,20,win,20)
  schemas <- ReadSchemaFile(schema)
  ts <- Transpose(schemas)
  defaults <- Transpose([First(ts),Second(ts)])

  parameters <- CreateParameters(defaults,paramsfile)  


  changed <- 0


  quit  <- MakeButton("Exit without saving",100,50,win,150)
  save <- MakeButton("Save file and exit",100,72,win,150)

  pnl <- EasyLabel("Parameters:",420,50,win,12)
  parnamebox <- EasyTextBox(parname,420-75,72-10,win,12,250,20)

  add <- MakeButton("New parameter set",260,72,win,150)
#  del <- MakeButton("Remove parameter",260,72,win,150)

  reset <- MakeButton("Reset to defaults",260,50,win,150)

  ##Now, make a grid showing values, etc., in the schema file
  ##We will set the rowheight adaptively..it should be set based on size 
  ##needed, but for now we will just stretch them all equally.

  ##out is [ui,vals,pluses,minuses,pmindex]
  out <- LayoutPGrid(schemas,parameters,win)

  ui <- First(out)
  vals <- Second(out)
  pluses <- Third(out)
  minuses <- Fourth(out)
  pmIndex <- Fifth(out)


  returns <- Sequence(1,Length(vals),1)


##add the click-on values at the end of the lists
  PushOnEnd(vals,save)
  PushOnEnd(vals,reset)
  PushOnEnd(vals,quit)
  PushOnEnd(vals,add)
  PushOnENd(vals,parnamebox)

  PushOnEnd(returns,"save")
  PushOnEnd(returns,"reset")
  PushOnEnd(returns,"quit")
  PushOnEnd(returns,"add")
  PushOnEnd(returns,"parnamebox")

##add the plus/minuses now 
 vals <- Merge(vals,pluses)
index <- 1
 loop(i,pmIndex)  ##add return index for pluses
 {
   PushOnEnd(returns,[i+1000,index])
   index <- index + 1
 }
  index <- 1
 vals <- Merge(vals,minuses)
 loop(i,pmIndex)  ##add return index for minuses
 {
   PushOnEnd(returns,[i+2000,index])
   index <- index + 1
 }



 Draw()
  ##Now, do a click-on loop to manage parameter updates. 
   cont <- 1
   while(cont)
   {
     resp <-   WaitForClickOnTarget(vals,returns)

    ##See if we need to edit something.
    if(resp == "quit")	
    {
      PushButton(quit,[0,0])
      cont <- 0
    }elseif(resp=="save")
    {

      PushButton(save,[0,0])

      pfile <- FileOpenOverwrite(paramsfile)

      loop(i,schemas)
      {

       value <- GetProperty(parameters,First(i))
       if(IsList(value))
       {
        ##Multi-parameter property:
       loop(j,value)
         {

          FilePrint(pfile,First(i)+"*,"+j)
         }
       }else{

         FilePrint(pfile,First(i)+","+value)

       }
      }

      cont <- 0

    } elseif(resp=="reset")
    {
     PushButton(reset,[0,0])
 
      pnames <- First(ts)
      defaults <- Second(ts)
      boxes <- SubList(vals,1,Length(schemas))
      loop(i,Transpose([pnames,defaults,boxes]))
      {
       SetProperty(parameters,First(i),Second(i))
       box <- Third(i)
       box.text <- Second(i)
      }
      Draw()

    }elseif(resp == "add")
    {
    ##this 'adds' a new parameter set, naming/saving it immediately.
      Pushbutton(add,[0,0])
      #this is really like 'save' but with a new name.

      ##figure out the new name:
      if(parnamebox.text == "default")
      {
        parname <- scriptname
        paramsfile <- path+scriptname

      }else {
	parname <- parnamebox.text
        paramsfile <- path+parname
      }
	if(not SubString(paramsfile,StringLength(paramsfile)-3,4)==".par")
	{
  	 parname <- parname + ".par"
	 paramsfile <- paramsfile + ".par"
	}
      

      pfile <- FileOpenOverwrite(paramsfile)

      loop(i,schemas)
      {

       value <- GetProperty(parameters,First(i))
       if(IsList(value))
       {
       loop(j,value)
         {

          FilePrint(pfile,First(i)+","+j)
         }
       }else{

         FilePrint(pfile,First(i)+","+value)

       }
      }

    }elseif(resp == "parnamebox")
    {
        box <- parnamebox
        relx <- First(gClick) - (box.x )
        rely <- Second(gClick) - (box.y )
        cursorpos <- GetTextBoxCursorFromClick(box,relx,rely)
	box.cursorpos<-cursorpos
	Draw()

	parname <- GetInput(box,"<return>",1)
        paramsfile <- path+parnamebox.text
	if(not SubString(paramsfile,StringLength(paramsfile)-3,4)==".par")
	{
  	 parname <- parname + ".par"
	 paramsfile <- paramsfile + ".par"
	}
	Draw()
  
    }elseif(IsList(resp))
    {
      ##plus or minus
      index <- First(resp)
      pmindex <- Second(resp)
      if(index > 2000)
      {    
         PushButton(Nth(minuses,pmindex),[0,0])
       }else{
         PushButton(Nth(pluses,pmindex),[0,0])
       }

    }  elseif(resp <= Length(schemas))
    {  ##Click and edit a parameter box:

        box <- Nth(vals,resp)
        relx <- First(gClick) - (box.x )
        rely <- Second(gClick) - (box.y )
        cursorpos <- GetTextBoxCursorFromClick(box,relx,rely)
	box.cursorpos<-cursorpos
	Draw()
	newval  <- GetInput(box,"<return>",1)
        SetProperty(parameters,First(Nth(schemas,resp)),newval)
     
    }
#   Draw()
   }
}

 return parname
}


##this does a layout on the parameter grid; suitable for 
##re-layout if the number of parameters change.
##We are given schemas, a list of triplets giving parametername,
##default value, description, and parameters, an object created by
##createparameters.
##
## multi-element properties are handled in the parameters
## as a list; within schemas,
## the names have a * at the end, and the values are (potentially)
## a comma-separated list.

define LayoutPGrid(schemas,parameters,win)
{
  pFontSize <- 11  ##this is the description font size; make a bit smaller for extra room.
  rowBase <- 80


  ##we need a better estimate of the length of the rows.
  rows <- []
  loop(i,GetPropertyList(parameters))
  {
     if(SubString(i,StringLength(i),1)=="*")
     {
       PushOnEnd(rows,SplitString(GetProperty(parameters,i),","))
     }else {
       PushOnEnd(rows,GetProperty(parameters,i))
     }
  }
  rows2 <- Flatten(rows)
  rowHeight <- Min([50,Floor(((gVideoHeight-5)-rowBase)/(Length(rows2)+2))])


  c1Base <- 100
  c1 <- 150
  c2 <- 100
  c3 <- 600


  head1 <- EasyLabel("Parameter name",c1Base+c1/2,rowBase+rowHeight/2,win,18)
  head2 <- EasyLabel("Value",c1Base+c1+c2/2,rowBase+rowHeight/2,win,18)
  head3 <- EasyLabel("Description",c1Base+c1+c2+c3/2,rowBase+rowHeight/2,win,18)

  ui <- []
  vals <- []
  pluses <- []
  minuses <- []
  pmIndex <- []

  prevparname <- ""
  counter <- 1
  row <- 1
  loop(i,schemas)
  {
     parname <- First(i)
     ##is this a multi-parameter set (specified with a *)
     singlepar <- 1

     if(SubString(parname,StringLength(parname),1)=="*")
     {
         parname <- SubString(parname,1,StringLength(parname)-1)
	 singlepar <- 0

        ##Schema is multi-parameter; the default values in the schema
	##are actually separated by commas.
	pvalues <- SplitString(Second(i),",")
	
       ##use CreateParameters to make sure these are converted to numbers

       fakeprop <- Repeat("fake",Length(pvalues))
       fakepar <- CreateParameters(Transpose([fakeprop,pvalues]),"")
       curvals <- fakepar.fake

     }else{
       curvals <- Second(i)
     }


     #Now, curval is either a list (for multi-parameters), or a value,
     ##based on the schema file.

     ##Use the pfile value in if it exists:
     if(PropertyExists(parameters,parname))
     {
       curvals <- GetProperty(parameters,parname)
     }

     if(not IsList(curvals))
     {
       curvals <- [curvals]
     }

     ##i is the schema for the current property, which we will still use for default parameters etc.
     ##curval is the current value from the parameter file or the schema (if no parameter file exists)


      loop(curval,curvals)
      {

      if(not singlepar)
      {
       ##Add +/- button for multiple parameters.
       tmpminus <- MakeButton("-",c1Base-40,rowbase+rowheight*(row+.5),win,18)
       tmpplus <- MakeButton("+",c1Base-20,rowbase+rowheight*(row+.5),win,18)
       PushOnEnd(ui,tmpminus)
       PushOnEnd(ui,tmpplus)
       PushOnEnd(pluses,tmpPlus)
       PushOnEnd(minuses,tmpMinus)
       PushOnEnd(pmIndex,row+1)

      }


      ##Now, add the UI elements for this parameter
      	

      r1 <- EasyTextbox(First(i)+"", c1Base,rowBase + rowHeight*row,win,12,c1-2,rowHeight-2)
      r2 <- EasyTextbox(curval+"", c1Base+c1,rowBase + rowHeight*row,win,12,c2-2,rowHeight-2)
      r3 <- EasyTextbox(Third(i)+" (default: ["+Second(i)+"])", c1Base+c1+c2,rowBase + rowHeight*row,win,pFontSize,c3-2,rowHeight-2)

      PushOnEnd(ui,r1)
      PushOnEnd(ui,r2)
      PushOnEnd(ui,r3)
      PushOnEnd(vals,r2)
      row <- row+ 1
    }

  }

  return [ui,vals,pluses,minuses,pmindex]
}

define ReadSchemaFile(filename)
{
   schemalist <- FileReadList(filename)
   list <- []
   loop(i,schemalist)
    {
       line <- SplitString(i,"|")
       PushOnEnd(list,line)
    }
  return list
}



##targetlist is a set of graphical objects,
##keylist is a set of keys whose corresponding 
##value should be returned when a graphical object is clicked upon.
## This modifies the built-in waitforclickontarget so that it will
## Return the button that is clicked, along with the target, 
## and the target object
define WaitForButtonClickOnTarget(targetlist,keylist)
{
  
  if(not IsList(targetlist))
  { 
    SignalFatalError("First argument of WaitForClickOnTarget(targetlist,keylist) must be a list of graphical objects")
  }

  if(not IsList(keylist))
  { 
    SignalFatalError("Second argument of WaitForClickOnTarget(targetlist,keylist) must be a list")
  }
  
  if(Length(targetlist) <> Length(keylist))
  {
    SignalFatalError("Arguments of WaitForClickOnTarget(targetlist,keylist) must be the same length")
  }

  obj <- ""
  ret <- ""
  testlist <- Reverse(Transpose([targetlist,keylist]))
   
   wait1 <- 1
   while(wait1)
     {
      wait2 <- 1
      while(wait2)
       {
         pos <- WaitForMouseButton()
         if(Nth(pos,4)=="<pressed>")
          {
            wait2 <- 0
            gClick <- pos
          }
       }

      newtargs <- []
	  
      loop(i,testlist)
          {

            if(Inside(pos,First(i)))
              {
	        obj <- First(i)
	        wait1 <- 0
                ret <- Nth(i,2)
                break
             }

          }
	  wait1 <- 0
     }
  ##Print([ret,pos,obj])
  return [ret,pos,obj]
}

##this returns a list of actual parameter files
## in the params\ directory.
##if the params\ directory does not exist, it returns an 
##empty list.  If it does exist but no .par files are there,
##it returns '["default"]'.  Otherwise, it appends the .par
## list to ["default"]


define GetParFiles()
{  
 paramsdir <- DirListToText(gDirChain)+"params"  
 if(FileExists(paramsdir))
  {
    parfiles <- Merge(["default"],
              Second(FilterDir(GetDirectoryListing(paramsdir),
                    gDirChain,"*.par")))
  } else {
    parfiles <- []
  }

 return parfiles
}


define GetConfigFiles()
{  
 dir <- DirListToText(gDirChain)  
 conffiles <- Second(FilterDir(GetDirectoryListing("./"),
                              gDirChain,"*.config"))
 return conffiles
}


define ListEqual(l1,l2)
{
  if(Length(l1)==Length(l2))
  {
   same <- 1


   loop(i,Transpose([l1,l2]))
    {
     if(not (First(i) == Nth(i,2)))
      {
        same <- 0
      }

    }
   } else {
     same <- 0
   } 
  return same
}



define UpdateScreenResPulldown(pd)
{



	  ##get a list of available screen modes:
 	  selected <- -1
	  currentxy <- gScreenRes
          screenmodes <- GetVideoModes()
	  screenmodes <- SortBy(screenmodes,First(Transpose(screenmodes)))

	  ##add 'current' and 'custom':
	  screenmodes <- Append(screenmodes,gCurrent)
	  screenmodes <- Append(screenmodes,gCustomText+gCustomScreenRes)

         ##if we have set a custom res, add another one that will let us edit 
         if(not gCustomScreenRes=="")
	  {
  	    screenmodes <- Append(screenmodes,gCustomText)
	  }



	  ##create a list of text-based screen modes to choose from:
          modes <- []
          index <- 1
	  loop(i, screenmodes)
	  {

	    ##most of the screenmodes will be list-pairs; but some will
	    ##be the labels we just added
	    if(IsList(i))
	    {
     	      tmp <- First(i)+"x"+Second(i)
	    }else{
	      tmp <- i
            }


	    if(tmp==currentxy)
	    { 
               tmp <- tmp + "*"
               selected <- index

       	    }

	     modes <- Append(modes, tmp)
	     index <- index + 1
	  }

	  ##Add the custom option to the end of each:

	  ##screenmodes is the nested list of resolutions
	  ##modes is the text that is inside pd
	  ##set the selected to 'default' if no match.
	  if(selected==-1)
	  {
	    selected <- Length(pd.list)-1
	  }
         
	  pd.selected <- selected
	  UpdatePulldown(pd,modes)
	  pd.selected <- selected
	  return screenmodes
}


define OpenManual(obj,click)
{
     #SystemCall(gManualLoc,"")	  
     #Print(gManualLoc)
   #   PopUpMessageBox(gManualLoc,obj.win)

    LaunchFile(gQuote+gManualLoc+gQuote)
#    LaunchFile("c:\Program Files (x86)\PEBL\doc\PEBLManual0.14.pdf")
}


define ChangeLaunchersize(obj,click)
{

   
    if(gParams.ScreenSize=="small")
      {
           gParams.ScreenSize <- "large"
      } else {
           gParams.screenSize <- "small"
      }

   SaveParamFile(gparams,"params/launcher.pbl.par")
 if(1) {
   PopupMessageBox(gRelaunchMessage,obj.win)

   }else{

   ##this stuff is too fussy to work right now.
   if(gScreenSize =="large")
   {
     gVideoWidth <- 1000
     gVideoheight <- 700
   }elseif(gScreenSize=="small")
   {
     gVideoWidth <- 1000
     gVideoheight <- 600
   }
   ResizeWindow(obj.win,gVideoWidth,gVideoheight)


   box <- gMessageBox.box
    ##we need to update the scrollbox:
   scrollH <- gVideoheight - gMessageBox.y-10
   lineheight <- gmessagebox.lineheight  
   obj.maxitems <- Floor(scrollH/lineheight)-2 
   box.height <- lineheight*obj.maxitems

   outline <- gmessageBox.outline
   outline.height <- scrollH
   outline.y <- gVideoWidth-scrollH/2-10
   outline
   gMessageBox.y <- scrollH
  }
   
}

define Aboutmessage(obj,click)
{
   MessageBox(gAboutText,obj.win)
}


define ExitPEBL(obj,click)
{
     Saveconfig(gconfigname)
      gCont <- 0
}

define GoToWeb(obj,click)
{
         #SystemCall("http://pebl.sourceforge.net","")	  
	 Launchfile("http://pebl.sourceforge.net")	  
}

define SetPassword(obj,click)
{
         PopUpScreen(obj.win)

}


define VisitWiki(obj,click)
{
       if(Length(gDirChain)>1)
       {
         root <- Nth(gDirChain,Length(gDirChain))+"/"
       }  else {
	     root <- ""
       }
       wikipagename <- root+Nth(gFlatFileList,gselected)
	   if(wikipagename=="." or wikipagename=="..")
        {
         wikipagename <- "Main_Page"
        }
	   Launchfile("http://pebl.sourceforge.net/wiki/index.php?title="+wikipagename)

}

define Review(obj,click)
{
    PopUpMessageBox("A web browser should open to the PEBL Review page at http://sourceforge.net/projects/pebl/reviews/",obj.win)
   Launchfile("http://sourceforge.net/projects/pebl/reviews/")

}

define Donate(obj,click)
{
      PopUpMessageBox("A web browser should open to the PEBL donation page at      http://www.superiorideas.org/node/139",obj.win)	
     Launchfile("http://www.superiorideas.org/node/139")
}


 
define ReloadStdOutErr(obj,click)
{

  ReadStdOutStdErr()
  if(gMessageBox.stdout)
  {
    UpdateStdOut(gMessageBox,[0,0])
  }  else{
    UpdateStdErr(gMessageBox,[0,0])
  }
}


##this reads the stdout/stderr files.
define ReadStdOutStdErr()
{	     
       file <- DirListToText(gDirChain)+"stdout.txt"
       if(FileExists(file))
          {
            gStdoutlist <- Merge(["stdout.txt"],FileReadList(file))
          }

         file <- DirListToText(gDirChain)+"stderr.txt"

          if(FileExists(file))
            {
  	       gStdErrlist <- Merge(["stderr.txt:"],FileReadList(file))
            }
}

define UpdateStdErr (obj,click)
{
      gMessageBox.list <- gStdErrList
      gMessageBox.selected <- Length(gStdErrList)

      ##This can take several seconds..:
      UpdateScrollBox(gMessageBox)
      gMessageBox.selected <- gMessageBox.numitems
      DrawScrollbox(gMessageBox)
      gSTdOutHighlight.x <- gMenuStdErr.x+gMenuStdErr.width/2
      gMessageBox.stderr <- 1
      gMessageBox.stdout <- 0
}

define UpdateStdOut (obj,click)
{
     gMessageBox.list <- gStdOutList
     gMessageBox.selected <- Length(gStdOutList)

      ##This can take several seconds..:
      UpdateScrollBox(gMessageBox)
      gMessageBox.selected <- gMessageBox.numitems
      DrawScrollbox(gMessageBox)
      gSTdOutHighlight.x <- gMenuStdOut.x+gMenuStdOut.width/2
      gMessageBox.stderr <- 0
      gMessageBox.stdout <- 1

}




define Dummy(obj,click)
{
   PopupMessageBox("Dummy",obj.win)
}

define Tutorial(obj,click)
{
   Launchfile("http://pebl.sourceforge.net/wiki/index.php/CogSci2011_Tutorial")
}
## This updates the things that change whenever the directory changes:
## the path, the screenshot, and the description.
##
define UpdateScreen(win)
 {


   x <- gPath.x-gPath.width/2
   y <- gPath.y-gPath.height/2
   gPath.text <- DirListToText(gDirChain)

    MoveCorner(gPath,x,y)

     ##figure out the name of the screenshot, if it exists:
     screenname <-DirListToText(gDirChain)+ 
                      Nth(gFlatFileList,gselected)+".png"

     ##update the screenshot, etc.
    descname <- DirListToText(gDirChain)+Nth(gflatfilelist,gselected)+".about.txt"

     if(FileExists(screenname))
      {
	     RemoveObject(gScreenshot,win)
	     gScreenshot <- MakeImage(screenname)

	     AddObject(gScreenshot,win)

 	     ##scale to 400x300
	     scalew <- 400/gScreenshot.width  
	     scaleh <- 300/gScreenshot.height
	     scale <- Min([scalew,scaleh])

	     gScreenshot.zoomX <- scale
	     gScreenshot.zoomY <- scale

	     Move(gScreenshot,gScreenshotbase.x,gScreenshotbase.y)

      } else {
	  
          ##try to find any .png file, provided it is a  subdirectory
           if(IsDirectory( DirListToText(gDirChain)+
                            Nth(gFlatFileList,gselected)))
	    {
	     list <- GetDirectoryListing( DirListToText(gDirChain)+
                                        Nth(gFlatFileList,gselected))

  	     pbls <- Second(FilterDir(list,gDirChain,"*.pbl"))
	     pngs <- Second(FilterDir(list,gDirChain,"*.png"))
             abouts <- Second(FilterDir(list,gDirChain,"*.about.txt"))

	     loop(i,pbls)
              {

	       if(IsMember(i+".png",pngs) and IsMember(i+".about.txt",abouts))
	         {

                    ##update the screenshot, etc.
                   descname <- DirListToText(gDirChain)+
                        Nth(gFlatFileList,gselected)+"/"+i+  ".about.txt"

                   screenname <-DirListToText(gDirChain)+
                        Nth(gFlatFileList,gselected)+"/"+i+".png"
  		   break
                  }

	       }
             

             
            if(FileExists(screenname))
              {
                  RemoveObject(gScreenshot,win)
      	          gScreenshot <- MakeImage(screenname)

                   AddObject(gScreenshot,win)

   	          ##scale to 400x300
	          scalew <- 400/gScreenshot.width  
	          scaleh <- 300/gScreenshot.height
 	          scale <- Min([scalew,scaleh])
 
	          gScreenshot.zoomX <- scale
	          gScreenshot.zoomY <- scale
	          Move(gscreenshot,gscreenshotbase.x,gscreenshotbase.y)
              } else {
  	      RemoveObject(gScreenshot,win)
	      gScreenshot <- gScreenshotdummy
	      AddObject(gScreenshot,win)

              }
           }else{
  	      RemoveObject(gScreenshot,win)
	      gScreenshot <- gScreenshotdummy
	      AddObject(gScreenshot,win)

      }
    }

     if(FileExists(descname))
      {
         text <- FileReadText(descname)
         SetScrollingText(gDescription,text,1)
	 DrawScrollBox(gDescription)
      } else {
         SetScrollingText(gDescription,gNoDesc,1)
	 DrawScrollBox(gDescription)
      }

}




define PopUpScreen(win)
{

##here is the 'nag' screen.
 text <- "Thank you for using PEBL: The Psychology Experiment Building Language. 

We appreciate your support! This software is licensed with the GPLv2, and is provided free of charge.  You are free to modify, share, and redistribute PEBL, and unlike most commercial tests, you can observe how it works and what it calculates. Please cite PEBL if you use it:

Mueller, S. T., & Piper, B. J. (2014). The Psychology Experiment Building Language (PEBL) and PEBL Test Battery. Journal of neuroscience methods, 222, 250259.

To skip this screen when you start-up, enter the password.  You can get a password by donating to the project, or by contributing in other ways to the project (translations, new tests, normative data, bug reports, writing wiki documentation, and so on)"


  boxwidth <- 651
  boxheight <- 301
  if(not IsWindow(win))
  { 
    SignalFatalError("PopupEntryBox(win) needs a window to be specified, not [" + win + "]")
  }



   	   
    xpos <- gVideoWidth/2
    ypos <- gVideoheight/2
  
   bgcol <- win.BGCOLOR

   popup  <- MakeCanvas(boxwidth,boxheight,MakeColor("grey60"))
   Move(popup,xpos,ypos)
   AddObject(popup,win)
   
   
   bg <- Rectangle(boxwidth/2,boxheight/2,boxwidth-2,boxheight-2,bgcol,1)
   AddObject(bg,popup)
   font <- MakeFont(gPEBLBaseFont,0,13,MakeColor("black"),bgcol,0)
   box <- MakeTextBox(text,font,boxwidth-20,boxheight-50)
   Move(box, 10,20)
   AddObject(box,popup)


   Draw(popup)
   Hide(bg)
   Hide(box)



##to accept clicks, these need to be on the main window.
   entrybox <-  EasyTextBox("",gVideoWidth/2+5,
                               popup.y+popup.height/2-70, 
                               win,13,180,20)
   ok    <- MakeButton("Enter/Confirm password:",gVideoWidth/2-95,entrybox.y+10,win,180)

   try  <- MakeButton("Let me try first",gVideoWidth/2-200,entrybox.y+45,win,170)

   donate <- MakeButton("Contribute and get password",gVideoWidth/2,entrybox.y+45,win,180)
   contribute <- MakeButton("How else can I help?",gVideoWidth/2+200,entrybox.y+45,win,170) 



   thermo <- Rectangle(entrybox.x-entrybox.width/2,entrybox.y-entrybox.height/2,
   0,entrybox.height,MakeColor("darkblue"),1)

   AddObject(thermo,win)

   Draw()
   totaltime <- 2000
   endtime <- GetTime()+totaltime
   timeleft <- endtime - GetTime()
   while( timeleft>0)
   {
      thermo.width <- entrybox.width* timeleft/totaltime
      MoveCorner(thermo,entrybox.x,entrybox.y)
      Draw()
      Wait(5)
      timeleft <- endtime - GetTime()
   }
   Hide(thermo)


   Draw()
 
  cont <- 1
  while(cont)
  {

   resp <- WaitForButtonClickOnTarget([entrybox,ok,try,donate,contribute],
                                      [1,2,3,4,5])

   id <- First(resp)
   click <- Second(resp)
   obj <- Third(resp)

   if(id==1)
    {

	   relx <- First(gClick) - (entrybox.x )
	   rely <- Second(gClick) - (entrybox.y )

	   entrybox.cursorpos <- (GetTextBoxCursorFromClick(entrybox,relx,
                                                                     rely))
	   Draw()
           pw  <- GetInput(entrybox,"<return>",1)

    }elseif(id==2)
    {
     PushButton(obj,gClick)
     ##check password here.
      pw <- entrybox.text
      passwordhash <- MD5Sum(pw)
#     Print(pw)
#     Print(passwordhash)

      gParams.pwhash <- passwordhash
      if(gParams.pwhash=="2627692e567165c7a474f3ea97c07912")
      {
        cont <- 0
      }else{
       PopUpMessageBox("Sorry, this password in incorrect.",win)
       entrybox.text <- ""
     }
    }elseif(id==3)
    {
     PushButton(obj,gClick)
     ##don't check password here.
     cont <- 0
     PopUpMessageBox("Please help support PEBL development or if you are able",win)
   
   }elseif(id==4){
     PushButton(obj,gClick)
     ##go to donation page
     Launchfile("http://www.superiorideas.org/node/139")
    PopUpMessageBox("A web browser should open to the PEBL donation page at      http://www.superiorideas.org/node/139",win)
 #    cont <- 0
   }elseif(id==5){
     PushButton(obj,gClick)
    PopUpMessageBox("A web browser should open to the PEBL contributions page at http://pebl.sourceforge.net/wiki/index.php/How_can_I_contribute",win)
     Launchfile("http://pebl.sourceforge.net/wiki/index.php/How_can_I_contribute")
  }


   Draw()
  }
   return entrybox.text
}


define SaveParamFile(params,file)
{
  plist <-[]
  loop(i,GetPropertyList(params))
   {
     PushOnEnd(plist, [i,GetProperty(params,i)])
   }
   FileSaveTable(plist,file)
}
